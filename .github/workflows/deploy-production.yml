name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check required secrets
        env:
          # Deployment secrets
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
          # App configuration
          NODE_ENV: ${{ secrets.NODE_ENV }}
          PORT: ${{ secrets.PORT }}
          HOST: ${{ secrets.HOST }}
          # Database configuration
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          # Redis configuration
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          # JWT configuration
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN: ${{ secrets.JWT_EXPIRES_IN }}
          JWT_REFRESH_EXPIRES_IN: ${{ secrets.JWT_REFRESH_EXPIRES_IN }}
          # Email configuration
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_PORT: ${{ secrets.EMAIL_PORT }}
          EMAIL_SECURE: ${{ secrets.EMAIL_SECURE }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          # App settings
          APP_NAME: ${{ secrets.APP_NAME }}
          APP_URL: ${{ secrets.APP_URL }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          APP_STORE_URL: ${{ secrets.APP_STORE_URL }}
          BCRYPT_ROUNDS: ${{ secrets.BCRYPT_ROUNDS }}
          PASSWORD_RESET_EXPIRES: ${{ secrets.PASSWORD_RESET_EXPIRES }}
          EMAIL_VERIFICATION_EXPIRES: ${{ secrets.EMAIL_VERIFICATION_EXPIRES }}
          # Google and Firebase configuration
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          INVITE_MATCH_WINDOW_SECONDS: ${{ secrets.INVITE_MATCH_WINDOW_SECONDS }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          FIREBASE_SERVICE_ACCOUNT_JSON: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          OAUTH_REDIRECT_URI: ${{ secrets.OAUTH_REDIRECT_URI }}
          # Additional app store URLs
          APP_STORE_URL_IOS: ${{ secrets.APP_STORE_URL_IOS }}
          APP_STORE_URL_ANDROID: ${{ secrets.APP_STORE_URL_ANDROID }}
          API_URL: ${{ secrets.API_URL }}
        run: |
          MISSING_SECRETS=()
          
          # Define variables to check
          REQUIRED_VARS=(
            # Deployment
            "PRODUCTION_HOST"
            "PRODUCTION_USER"
            "PRODUCTION_PATH"
            "SSH_PRIVATE_KEY"
            "SSH_PASSPHRASE"
            # App
            "NODE_ENV"
            "PORT"
            "HOST"
            # Database
            "DB_HOST"
            "DB_PORT"
            "DB_NAME"
            "DB_USER"
            "DB_PASSWORD"
            # Redis
            "REDIS_HOST"
            "REDIS_PORT"
            "REDIS_PASSWORD"
            # JWT
            "JWT_SECRET"
            "JWT_EXPIRES_IN"
            "JWT_REFRESH_EXPIRES_IN"
            # Email
            "EMAIL_HOST"
            "EMAIL_PORT"
            "EMAIL_SECURE"
            "EMAIL_USER"
            "EMAIL_PASS"
            "EMAIL_FROM"
            # App settings
            "APP_NAME"
            "APP_URL"
            "API_URL"
            "FRONTEND_URL"
            "APP_STORE_URL"
            "BCRYPT_ROUNDS"
            "PASSWORD_RESET_EXPIRES"
            "EMAIL_VERIFICATION_EXPIRES"
            # Google and Firebase
            "GOOGLE_CLIENT_ID"
            "INVITE_MATCH_WINDOW_SECONDS"
            "GOOGLE_API_KEY"
            "GEMINI_API_KEY"
            "FIREBASE_SERVICE_ACCOUNT_JSON"
            # Additional app store URLs
            "APP_STORE_URL_IOS"
            "APP_STORE_URL_ANDROID"
          )
            
          # Check only our required variables
          for var in "${REQUIRED_VARS[@]}"; do
            if [ -z "${!var}" ]; then
              MISSING_SECRETS+=($var)
            fi
          done

          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "❌ Missing required secrets:"
            printf '%s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi

          echo "✅ All required secrets are set"

  deploy:
    needs: [validate]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Build TypeScript
        run: npm run build

      - name: Setup SSH directory
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
          # Write the private key and remove its passphrase
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key_with_pass
          chmod 600 ~/.ssh/deploy_key_with_pass
          # Remove passphrase from the key
          ssh-keygen -p -P "${{ secrets.SSH_PASSPHRASE }}" -N "" -f ~/.ssh/deploy_key_with_pass
          mv ~/.ssh/deploy_key_with_pass ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          echo "SSH directory setup complete"

      - name: Create .env file
        run: |
          cat << EOF > .env
          # Server Configuration
          NODE_ENV=${{ secrets.NODE_ENV }}
          PORT=${{ secrets.PORT }}
          HOST=${{ secrets.HOST }}

          # Database Configuration
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}

          # Redis Configuration
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          JWT_REFRESH_EXPIRES_IN=${{ secrets.JWT_REFRESH_EXPIRES_IN }}

          # Email Configuration
          EMAIL_HOST=${{ secrets.EMAIL_HOST }}
          EMAIL_PORT=${{ secrets.EMAIL_PORT }}
          EMAIL_SECURE=${{ secrets.EMAIL_SECURE }}
          EMAIL_USER=${{ secrets.EMAIL_USER }}
          EMAIL_PASS=${{ secrets.EMAIL_PASS }}
          EMAIL_FROM=${{ secrets.EMAIL_FROM }}

          # Application Configuration
          APP_NAME=${{ secrets.APP_NAME }}
          APP_URL=${{ secrets.APP_URL }}
          API_URL=${{ secrets.API_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          APP_STORE_URL=${{ secrets.APP_STORE_URL }}
          APP_STORE_URL_IOS=${{ secrets.APP_STORE_URL_IOS }}
          APP_STORE_URL_ANDROID=${{ secrets.APP_STORE_URL_ANDROID }}
          BCRYPT_ROUNDS=${{ secrets.BCRYPT_ROUNDS }}
          PASSWORD_RESET_EXPIRES=${{ secrets.PASSWORD_RESET_EXPIRES }}
          EMAIL_VERIFICATION_EXPIRES=${{ secrets.EMAIL_VERIFICATION_EXPIRES }}
          INVITE_MATCH_WINDOW_SECONDS=${{ secrets.INVITE_MATCH_WINDOW_SECONDS }}
          PRODUCTION_PATH=${{ secrets.PRODUCTION_PATH }}
          # Google and Firebase Configuration
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}
          GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          FIREBASE_SERVICE_ACCOUNT_JSON=${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          OAUTH_REDIRECT_URI=${{ secrets.OAUTH_REDIRECT_URI }}
          EOF

      - name: Check and prepare server
        run: |
          # First test SSH connection
          echo "Testing SSH connection..."
          ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "sudo -i pwd && sudo -i whoami"

          # Create the check software script
          echo "#!/bin/bash" > check_software.sh
          echo "# Function to check if a command exists" >> check_software.sh
          echo "command_exists() {" >> check_software.sh
          echo "  command -v \"\$1\" >/dev/null 2>&1" >> check_software.sh
          echo "}" >> check_software.sh
          echo "" >> check_software.sh
          echo "# Check and install Node.js" >> check_software.sh
          echo "if command_exists node; then" >> check_software.sh
          echo "  echo \"✅ Node.js is installed (\$(node --version))\"" >> check_software.sh
          echo "else" >> check_software.sh
          echo "  echo \"⚙️ Installing Node.js...\"" >> check_software.sh
          echo "  curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -" >> check_software.sh
          echo "  sudo apt-get install -y nodejs" >> check_software.sh
          echo "  echo \"✅ Node.js installed successfully\"" >> check_software.sh
          echo "fi" >> check_software.sh
          echo "" >> check_software.sh
          echo "# Check and install PM2" >> check_software.sh
          echo "if command_exists pm2; then" >> check_software.sh
          echo "  echo \"✅ PM2 is installed (\$(pm2 --version))\"" >> check_software.sh
          echo "else" >> check_software.sh
          echo "  echo \"⚙️ Installing PM2...\"" >> check_software.sh
          echo "  sudo npm install -g pm2" >> check_software.sh
          echo "  echo \"✅ PM2 installed successfully\"" >> check_software.sh
          echo "  # Setup PM2 startup script" >> check_software.sh
          echo "  sudo pm2 startup" >> check_software.sh
          echo "fi" >> check_software.sh
          
          chmod +x check_software.sh
          scp -v -i ~/.ssh/deploy_key -o IdentitiesOnly=yes check_software.sh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/
          ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "bash /tmp/check_software.sh && rm /tmp/check_software.sh"

          # Create prepare directory script
          echo "#!/bin/bash" > prepare_directory.sh
          echo "DEPLOY_PATH=\"\$1\"" >> prepare_directory.sh
          echo "" >> prepare_directory.sh
          echo "if [ ! -d \"\${DEPLOY_PATH}\" ]; then" >> prepare_directory.sh
          echo "  echo \"Creating deployment directory...\"" >> prepare_directory.sh
          echo "  sudo mkdir -p \"\${DEPLOY_PATH}\"" >> prepare_directory.sh
          echo "  echo \"✅ Deployment directory created\"" >> prepare_directory.sh
          echo "else" >> prepare_directory.sh
          echo "  echo \"✅ Deployment directory already exists\"" >> prepare_directory.sh
          echo "fi" >> prepare_directory.sh
          echo "" >> prepare_directory.sh
          echo "# Set correct ownership and permissions" >> prepare_directory.sh
          echo "sudo chown -R \$(whoami):\$(whoami) \"\${DEPLOY_PATH}\"" >> prepare_directory.sh
          echo "sudo chmod 755 \"\${DEPLOY_PATH}\"" >> prepare_directory.sh
          echo "echo \"✅ Directory permissions set correctly\"" >> prepare_directory.sh
          echo "" >> prepare_directory.sh
          echo "# Create logs directory if it doesn't exist" >> prepare_directory.sh
          echo "if [ ! -d \"\${DEPLOY_PATH}/logs\" ]; then" >> prepare_directory.sh
          echo "  mkdir -p \"\${DEPLOY_PATH}/logs\"" >> prepare_directory.sh
          echo "  echo \"✅ Logs directory created\"" >> prepare_directory.sh
          echo "fi" >> prepare_directory.sh
          
          chmod +x prepare_directory.sh
          scp -v -i ~/.ssh/deploy_key -o IdentitiesOnly=yes prepare_directory.sh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/
          ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "bash /tmp/prepare_directory.sh '${{ secrets.PRODUCTION_PATH }}' && rm /tmp/prepare_directory.sh"

      - name: Create deployment archive
        run: |
          echo "Creating deployment archive..."
          
          # Create list of files to include (safer approach)
          echo "Collecting files for deployment..."
          
          # Create a temporary file list
          find . -type f \
            -not -path './.git/*' \
            -not -path './node_modules/*' \
            -not -path './.github/*' \
            -not -path './logs/*' \
            -not -name '.env*' \
            -not -name '*.log' \
            -not -name '*.tmp' \
            -not -name '*.temp' \
            -not -name '.DS_Store' \
            -not -name 'check_software.sh' \
            -not -name 'prepare_directory.sh' \
            -not -name 'deploy.tar.gz' > /tmp/file_list.txt
          
          echo "Files to be included:"
          cat /tmp/file_list.txt | head -20
          echo "Total files: $(wc -l < /tmp/file_list.txt)"
          
          # Create archive using the file list
          echo "Creating archive from file list..."
          tar -czf deploy.tar.gz -T /tmp/file_list.txt
          
          echo "Archive created. Size:"
          ls -lh deploy.tar.gz
          
          # Clean up file list
          rm -f /tmp/file_list.txt
          
          # Test archive integrity
          echo "Testing archive integrity:"
          tar -tzf deploy.tar.gz | head -10
          
          echo "✅ Deployment archive created successfully"

      - name: Deploy to server
        run: |
          # Verify all required files exist before deployment
          echo "Verifying deployment files..."
          if [ ! -f "deploy.tar.gz" ]; then
            echo "❌ deploy.tar.gz not found!"
            exit 1
          fi
          
          if [ ! -f ".env" ]; then
            echo "❌ .env file not found!"
            exit 1
          fi
          
          if [ ! -f "deploy.sh" ]; then
            echo "❌ deploy.sh not found!"
            exit 1
          fi
          
          echo "✅ All deployment files verified"
          ls -lh deploy.tar.gz .env deploy.sh
          
          # Copy files to server
          echo "Copying files to server..."
          scp -v -i ~/.ssh/deploy_key -o IdentitiesOnly=yes \
            deploy.tar.gz \
            .env \
            deploy.sh \
            ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PATH }}/

          # Execute deployment on server 
          echo "Executing deployment on server..."
          ssh -v -i ~/.ssh/deploy_key -o IdentitiesOnly=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3 ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd ${{ secrets.PRODUCTION_PATH }}
            
            # Backup existing node_modules if it exists
            if [ -d 'node_modules' ]; then
              echo 'Backing up node_modules...'
              mv node_modules node_modules_backup
            fi
            
            # Extract new files
            echo 'Extracting deployment files...'
            tar xzf deploy.tar.gz
            rm deploy.tar.gz
            
            # Restore node_modules if backup exists  
            if [ -d 'node_modules_backup' ]; then
              echo 'Restoring node_modules...'
              rm -rf node_modules
              mv node_modules_backup node_modules
            fi
            
            # Make deploy script executable and run it
            chmod +x deploy.sh
            echo 'Starting deployment script...'
            timeout 300 ./deploy.sh '${{ secrets.PRODUCTION_PATH }}'
            
            echo 'Deployment script completed'
            echo 'Final PM2 status:'
            pm2 list
          "

      - name: Cleanup
        if: always()
        run: |
          rm -f .env
          rm -f ~/.ssh/deploy_key
          rm -f deploy.tar.gz
          rm -f check_software.sh
          rm -f prepare_directory.sh
          rm -rf /tmp/deploy_staging
